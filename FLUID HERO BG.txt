Hey JC — I dug into that hero and here’s the full teardown. Short version: it’s not a plain CSS gradient mask; it’s a WebGL fluid simulation drawn to a <canvas> that sits behind the hero text. Your cursor injects “dye” (color) and velocity into the sim, and a blurred/noised overlay makes it feel like a soft, smoky gradient that reveals as you hover.

Visual behavior (what you’re seeing)

A mostly-black hero. When you move the cursor, a soft, oval-ish wash of color blooms under the pointer and trails off with gentle advection, like ink in water.

The color never becomes harsh; it’s feathered and slightly grainy. This comes from canvas blur plus a subtle noise layer blended over the canvas.

Text and CTA sit above everything; the effect is purely background ambiance, not a mask on the type.

Structure (how it’s layered)

Container: a .fluid-container positioned absolute/inset:0 behind the hero copy so it fills the viewport.

Canvas: a <canvas id="fluid"> sized a bit larger than the viewport (overflow hidden) to avoid edge clipping while the fluid swirls. A CSS blur is applied to soften the sim.

Noise overlay: a full-bleed div on top of the canvas with an SVG fractal noise background and a blending mode (e.g., mix-blend-mode: color-burn or similar) at low opacity. This adds film-grain/organic texture so gradients don’t look sterile.

The engine (what powers the motion)

It’s a WebGL fluid simulation (think of PavelDoGreat’s WebGL Fluid style). A small script initializes the sim on the #fluid canvas and maps cursor events to splat injections:

Color (dye): the “ink” that becomes the gradient. Often defined as an array of RGB triplets or a gradient ramp.

Emitter size: radius of each splat (how big the bloom is).

Velocity & curl: how “swirly” vs. “glassy” it feels.

Dissipation / pressure iterations: how quickly dye fades and how stable/viscous the fluid feels.

Pointer moves add both dye and velocity vectors at the cursor point each frame. The sim advects the dye field over time; that’s the trailing wake.

Why it feels like a gradient “reveal”

The “gradient” isn’t a static image; you’re literally painting color into a fluid buffer. The blur filter on the canvas + the noise overlay make it read as a soft gradient reveal instead of liquid streaks.

Keeping curl modest and dissipation relatively high prevents hard eddies; instead you get silky, lens-flare-like bands of color.

Typical implementation (clean room replica)

HTML

<section class="hero">
  <div class="fluid-container">
    <canvas id="fluid"></canvas>
    <div class="fluid-noise" aria-hidden="true"></div>
  </div>

  <div class="container">
    <h1>AGENCIA DE <em>BRANDING</em></h1>
    <a class="cta" href="/contacto/">PIDE PRESUPUESTO</a>
  </div>
</section>


CSS (key ideas)

.hero { position: relative; min-height: 100vh; background:#000; overflow: clip; }
.fluid-container { position:absolute; inset:0; z-index:0; background:#000; overflow:hidden; }
#fluid {
  position:absolute; inset:-3rem;            /* overscan to hide edges */
  width: calc(100% + 6rem);
  height: calc(100vh + 6rem);
  filter: blur(15px);                         /* soften fluid -> gradienty */
  opacity: .5;                                /* keep it subtle */
}
.fluid-noise {
  position:absolute; inset:0; pointer-events:none; z-index:1;
  opacity:.2; mix-blend-mode:color-burn;      /* texture into the color */
  background-image: url("data:image/svg+xml;utf8,\
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 600'>\
<filter id='a'><feTurbulence type='fractalNoise' baseFrequency='.99' numOctaves='20' stitchTiles='stitch'/></filter>\
<rect width='100%' height='100%' filter='url(#a)'/>\
</svg>");
}
.hero .container { position:relative; z-index:2; color:#fff; }


JS (using a WebGL fluid library pattern)

<script type="module">
import { Fluid } from './webgl-fluid-lib.js'; // or inline the lib/minified file

const canvas = document.querySelector('#fluid');
const fluid = new Fluid(canvas);

// Behavior tuning — these values produce a soft “gradient wash”
fluid.mapBehaviors({
  // Resolution
  sim_resolution: 128,
  dye_resolution: 512,

  // “Feel”
  dissipation: 0.985,          // higher = fades faster
  velocity: 0.85,              // damping of motion
  pressure_iteration: 15,      // stability
  curl: 0.0,                   // keep swirls low for smooth gradients
  emitter_size: canvas.width * 0.0009, // pointer splat radius

  // Color
  multi_color: true,
  fluid_color: [
    [0.00, 0.00, 0.00],        // near-black “anchor” (keeps it moody)
    [0.40, 0.20, 0.00]         // warm teal/amber hue; tweak to your brand
  ],

  // Background / Bloom (optional)
  render_bloom: false,
  background_color: { r: 15, g: 15, b: 15 },
});

fluid.activate();

// (Library internally binds pointermove/touch to add “splat” color+velocity)
// If you roll your own, you’d call fluid.addSplat(x, y, dx, dy, color, radius) on pointer events.
</script>

Why specific choices matter

Overscanning the canvas (inset:-3rem, bigger width/height) prevents the sim’s field from hard-clipping at the viewport edges when you fling the cursor to corners.

CSS blur + 50% opacity on the canvas: turns liquid detail into cinematic “glow” and keeps text legible.

Noise overlay with mix-blend-mode: breaks banding, adds grain so the gradient feels physical rather than digital.

Low curl, higher dissipation: gives you smooth, airbrushed trails instead of turbulent ripples.

Performance notes

The heaviest cost is the WebGL sim (dye/velocity passes + pressure solve). Keep sim/dye resolution modest on mobile (e.g., 96/256). You can also:

Drop to a static gradient on prefers-reduced-motion.

Pause the sim when the tab is hidden or the hero is scrolled out (IntersectionObserver).

Debounce pointer splats so you’re not injecting every micro-move.

How I’d tailor it for your brands

Palette: swap fluid_color to your brand ramps (e.g., deep indigo → electric cyan for fintech; earthy umber → saffron for food).

Mood: raise curl a touch for more “energy” (tech/startup), lower it to near-zero for luxury.

Art direction: add a very faint radial vignette on the hero to center the eye and keep edges darker.

Accessibility: ensure color contrast over the brightest bloom stays WCAG-safe; clamp the sim’s max RGB or fade the canvas slightly when the cursor is near text.

If you want, I can turn this into a Webflow-ready embed (custom code block) with a small toggle to fall back to a static gradient on mobile and reduced-motion systems.